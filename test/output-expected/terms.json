[
  {
    "shortDesc": "",
    "term": "China",
    "hint": "",
    "longDesc": "GIVEN there is an HTML-single-line-comment beginning with 'Aliases:'\nAND aliases contain unicode word characters\nTHEN they MUST still be separated correctly",
    "anchor": "#china",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [
      "中国zhōngguó",
      "zhōngguó中国",
      "中zhōngguó国",
      "zhōng中国guó"
    ],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "dolor",
    "hint": "↴",
    "longDesc": "foo",
    "anchor": "#dolor",
    "glossary": {
      "file": "./glossary.md",
      "termHint": "↴",
      "basePath": "/{redacted}/input/glossary.md",
      "outPath": "/{redacted}/output-actual/glossary.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN full description is a blockquote",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-full-description-is-a-blockquote",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN long description has a link",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description with a link MUST be complete, too.",
    "anchor": "#given-long-description-has-a-link",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN long description is a blockquote",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-long-description-is-a-blockquote",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description with a link MUST be detected completely.",
    "term": "GIVEN short description has a link",
    "hint": "ⓕ",
    "longDesc": "THEN short description with a link MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-short-description-has-a-link",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN short description is a blockquote",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-short-description-is-a-blockquote",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN short description is bold WITH fullstop excluded",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-short-description-is-bold-with-fullstop-excluded",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN short description is bold WITH fullstop included",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-short-description-is-bold-with-fullstop-included",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN short description is italic WITH fullstop excluded",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-short-description-is-italic-with-fullstop-excluded",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "THEN short description MUST be detected completely.",
    "term": "GIVEN short description is italic WITH fullstop included",
    "hint": "ⓕ",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#given-short-description-is-italic-with-fullstop-included",
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/input/glossary_formatted.md",
      "outPath": "/{redacted}/output-actual/glossary_formatted.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "Lorem ipsum is the worlds most famous, most beloved piece of nonsense.",
    "term": "Lorem ipsum",
    "hint": "↴",
    "longDesc": "Lorem ipsum is the worlds most famous, most beloved piece of nonsense. It's\nthe best of literature. A poem dedicated to space - space that's seamingly\nwaiting to be filled with something meaningful even though Lorem ipsum is\nalready meaningful because it only exists due to space being already filled\nwith life on a tiny planet earth.",
    "anchor": "#lorem-ipsum",
    "glossary": {
      "file": "./glossary.md",
      "termHint": "↴",
      "basePath": "/{redacted}/input/glossary.md",
      "outPath": "/{redacted}/output-actual/glossary.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "sit",
    "hint": "↴",
    "longDesc": "",
    "anchor": "#sit",
    "glossary": {
      "file": "./glossary.md",
      "termHint": "↴",
      "basePath": "/{redacted}/input/glossary.md",
      "outPath": "/{redacted}/output-actual/glossary.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "Term 1",
    "hint": "",
    "longDesc": "GIVEN there is an HTML-single-line-comment beginning with 'Aliases:' THEN the\nsubsequent comma-separated words MUST be detected as the term's aliases.",
    "anchor": "#term-1",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [
      "T1 Alias1",
      "T1-Alias2",
      "T1.Alias3"
    ],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "Term 2",
    "hint": "",
    "longDesc": "GIVEN there is an HTML-multi-line-comment beginning with 'Aliases:' THEN the\nsubsequent comma-separated words MUST be detected as the term's aliases.",
    "anchor": "#term-2",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [
      "T2 Alias1",
      "T2-Alias2",
      "T2.Alias3"
    ],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "Term 3",
    "hint": "",
    "longDesc": "GIVEN there is an HTML-multi-line-comment beginning with 'Aliases:' THEN the\nsubsequent comma-separated lines of words MUST be detected as the term's aliases.",
    "anchor": "#term-3",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [
      "T3 Alias1",
      "T3-Alias2",
      "T3.Alias3"
    ],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "Term 4",
    "hint": "",
    "longDesc": "GIVEN there is an HTML-multi-line-comment beginning with 'Aliases:' and an empty\nline THEN the subsequent comma-separated lines of words MUST be detected as the\nterm's aliases.",
    "anchor": "#term-4",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [
      "T4 Alias1",
      "T4-Alias2",
      "T4.Alias3"
    ],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "Term 5",
    "hint": "",
    "longDesc": "GIVEN there is an HTML-single-line-comment beginning with 'Aliases:'\nAND the comment ends with a trailing comma\nTHEN this MUST NOT result in an infinite loop or out-of-memory error\nas has been reported in #26",
    "anchor": "#term-5",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [
      "T5-Alias1",
      "T5-Alias2"
    ],
    "ignoreCase": false
  },
  {
    "shortDesc": "",
    "term": "Unicode Support",
    "hint": "",
    "longDesc": "",
    "anchor": "#unicode-support",
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "termHint": "",
      "basePath": "/{redacted}/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "regex": {},
    "aliases": [],
    "ignoreCase": false
  }
]
