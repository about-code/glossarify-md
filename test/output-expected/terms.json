[
  {
    "term": "lowercase",
    "shortDesc": "",
    "longDesc": "",
    "anchor": "#lowercase",
    "regex": {},
    "glossary": {
      "file": "./paths/uppercase/Glossary_Uppercase.md",
      "basePath": "/{redacted}/test/input/paths/uppercase/Glossary_Uppercase.md",
      "outPath": "/{redacted}/test/output-actual/paths/uppercase/Glossary_Uppercase.md"
    },
    "aliases": []
  },
  {
    "term": "Uppercase",
    "shortDesc": "",
    "longDesc": "",
    "anchor": "#uppercase",
    "regex": {},
    "glossary": {
      "file": "./paths/uppercase/Glossary_Uppercase.md",
      "basePath": "/{redacted}/test/input/paths/uppercase/Glossary_Uppercase.md",
      "outPath": "/{redacted}/test/output-actual/paths/uppercase/Glossary_Uppercase.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN long description has a link",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description with a link MUST be complete, too.",
    "anchor": "#when-long-description-has-a-link",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN short description has a link",
    "hint": "ⓕ",
    "shortDesc": "THEN short description with a link MUST be detected completely.",
    "longDesc": "THEN short description with a link MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-short-description-has-a-link",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN short description is bold WITH fullstop excluded",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-short-description-is-bold-with-fullstop-excluded",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN short description is bold WITH fullstop included",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-short-description-is-bold-with-fullstop-included",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN short description is italic WITH fullstop excluded",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-short-description-is-italic-with-fullstop-excluded",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN short description is italic WITH fullstop included",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-short-description-is-italic-with-fullstop-included",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN full description is a blockquote",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-full-description-is-a-blockquote",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN long description is a blockquote",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-long-description-is-a-blockquote",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "WHEN short description is a blockquote",
    "hint": "ⓕ",
    "shortDesc": "THEN short description MUST be detected completely.",
    "longDesc": "THEN short description MUST be detected completely. AND long description MUST be complete, too.",
    "anchor": "#when-short-description-is-a-blockquote",
    "regex": {},
    "glossary": {
      "file": "./glossary_formatted.md",
      "termHint": "ⓕ",
      "basePath": "/{redacted}/test/input/glossary_formatted.md",
      "outPath": "/{redacted}/test/output-actual/glossary_formatted.md"
    },
    "aliases": []
  },
  {
    "term": "sit",
    "hint": "↴",
    "shortDesc": "",
    "longDesc": "",
    "anchor": "#sit",
    "regex": {},
    "glossary": {
      "file": "./glossary.md",
      "termHint": "↴",
      "basePath": "/{redacted}/test/input/glossary.md",
      "outPath": "/{redacted}/test/output-actual/glossary.md"
    },
    "aliases": []
  },
  {
    "term": "dolor",
    "hint": "↴",
    "shortDesc": "",
    "longDesc": "foo",
    "anchor": "#dolor",
    "regex": {},
    "glossary": {
      "file": "./glossary.md",
      "termHint": "↴",
      "basePath": "/{redacted}/test/input/glossary.md",
      "outPath": "/{redacted}/test/output-actual/glossary.md"
    },
    "aliases": []
  },
  {
    "term": "Lorem ipsum",
    "hint": "↴",
    "shortDesc": "Lorem ipsum is the worlds most famous, most beloved piece of nonsense.",
    "longDesc": "Lorem ipsum is the worlds most famous, most beloved piece of nonsense. It's\nthe best of literature. A poem dedicated to space - space that's seamingly\nwaiting to be filled with something meaningful even though Lorem ipsum is\nalready meaningful because it only exists due to space being already filled\nwith life on a tiny planet earth.",
    "anchor": "#lorem-ipsum",
    "regex": {},
    "glossary": {
      "file": "./glossary.md",
      "termHint": "↴",
      "basePath": "/{redacted}/test/input/glossary.md",
      "outPath": "/{redacted}/test/output-actual/glossary.md"
    },
    "aliases": []
  },
  {
    "term": "Term 4",
    "shortDesc": "",
    "longDesc": "WHEN there is an HTML-multi-line-comment beginning with 'Aliases:' and an empty\nline THEN the subsequent comma-separated lines of words MUST be detected as the\nterm's aliases.",
    "anchor": "#term-4",
    "regex": {},
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "basePath": "/{redacted}/test/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/test/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "aliases": [
      "T4 Alias1",
      "T4-Alias2",
      "T4.Alias3"
    ]
  },
  {
    "term": "Term 3",
    "shortDesc": "",
    "longDesc": "WHEN there is an HTML-multi-line-comment beginning with 'Aliases:' THEN the\nsubsequent comma-separated lines of words MUST be detected as the term's aliases.",
    "anchor": "#term-3",
    "regex": {},
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "basePath": "/{redacted}/test/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/test/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "aliases": [
      "T3 Alias1",
      "T3-Alias2",
      "T3.Alias3"
    ]
  },
  {
    "term": "Term 2",
    "shortDesc": "",
    "longDesc": "WHEN there is an HTML-multi-line-comment beginning with 'Aliases:' THEN the\nsubsequent comma-separated words MUST be detected as the term's aliases.",
    "anchor": "#term-2",
    "regex": {},
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "basePath": "/{redacted}/test/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/test/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "aliases": [
      "T2 Alias1",
      "T2-Alias2",
      "T2.Alias3"
    ]
  },
  {
    "term": "Term 1",
    "shortDesc": "",
    "longDesc": "WHEN there is an HTML-single-line-comment beginning with 'Aliases:' THEN the\nsubsequent comma-separated words MUST be detected as the term's aliases.",
    "anchor": "#term-1",
    "regex": {},
    "glossary": {
      "file": "./features/aliases_and_synonyms/glossary.md",
      "basePath": "/{redacted}/test/input/features/aliases_and_synonyms/glossary.md",
      "outPath": "/{redacted}/test/output-actual/features/aliases_and_synonyms/glossary.md"
    },
    "aliases": [
      "T1 Alias1",
      "T1-Alias2",
      "T1.Alias3"
    ]
  },
  {
    "term": "Cite of Einstein",
    "hint": "✶",
    "shortDesc": "",
    "longDesc": "Keep things as simple as possible but not simplier.",
    "anchor": "#cite-of-einstein",
    "regex": {},
    "glossary": {
      "file": "./cites.md",
      "termHint": "✶",
      "basePath": "/{redacted}/test/input/cites.md",
      "outPath": "/{redacted}/test/output-actual/cites.md"
    },
    "aliases": []
  }
]
